\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[brazil]{babel}
\usepackage{booktabs}
\usepackage{hyperref}

\lstset{
    language=Python,
    basicstyle=\ttfamily\tiny,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{green!60!black},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=6pt,
    backgroundcolor=\color{white},
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    frame=single,
    tabsize=2,
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false,
    columns=flexible,
    xleftmargin=0.5cm,
    escapeinside={\%*}{*)},
    inputencoding=utf8,
    extendedchars=true,
}

\begin{document}

\title{Simulação do controle FOC de motor BLAC aplicado a um motor BLDC\\
}

\author{\IEEEauthorblockN{1\textsuperscript{st} Felipe Lenschow}
\IEEEauthorblockA{\textit{Programa de Pós-Graduação em Engenharia Elétrica} \\
\textit{Universidade do Estado de Santa Catarina}\\
Joinville, Santa Catarina, Brasil \\
felipe.lenschow@edu.udesc.br}
}

\maketitle

\begin{abstract}
This paper presents the modeling and simulation of the drive using 
Field-Oriented Control (FOC), comparing its performance when applied 
to a Brushless AC (BLAC) motor, for which it was designed, and to a 
Brushless DC (BLDC) motor. The mathematical model in the dq reference 
frame is derived for both machines, and the control strategy employed 
is the Proportional-Integral (PI) controller, following the development 
of \cite{b3}. The simulation, developed in Python, demonstrates that, 
although FOC maintains precise speed control for both motors, it 
introduces significant torque ripple in the BLDC motor due to its 
trapezoidal back-electromotive force. The results highlight the 
limitations of standard FOC for BLDC machines in applications requiring 
low torque ripple.
\end{abstract}

\begin{IEEEkeywords}
PMSM, BLDC, BLAC, FOC, Simulation, Python, Motor Control
\end{IEEEkeywords}

% \tableofcontents

\section{Introdução}
Motores Síncronos de Ímãs Permanentes (PMSMs) são amplamente utilizados em 
aplicações industriais, veículos elétricos e robótica devido à sua alta 
eficiência, alta densidade de potência e excelente desempenho dinâmico. 
Para alcançar um controle de alto desempenho, o Controle Orientado a 
Campo (FOC) é comumente empregado. O FOC permite o controle independente 
de fluxo e torque transformando as correntes trifásicas do estator para 
um referencial girante dq, alinhado com o fluxo do rotor \cite{pillay1989}, 
porém, tal método de controle apresenta limitações quando aplicado a motores 
de corrente contínua sem escovas (BLDC), que possuem uma força contra-eletromotriz 
trapezoidal, em vez de senoidal como nos motores de corrente alternada sem escovas (BLACs).

Este artigo desenvolve um ambiente de simulação para um 
sistema de acionamento PMSM. A simulação inclui a física do motor, 
o inversor de frequência e o algoritmo FOC. O objetivo é 
fornecer uma compreensão clara da dinâmica do sistema, validando o 
controle desenvolvido em \cite{b3}, bem como mostrar os efeitos do 
mesmo FOC na dinâmica do motor BLDC.

A organização deste trabalho é apresentada a seguir. A Seção \ref{sec:model} 
descreve o modelo matemático do sistema e as diferenças entre os motores. 
A Seção \ref{sec:control} detalha a estratégia de controle 
e o projeto dos controladores. 
A Seção \ref{sec:simulator} apresenta a implementação do simulador. 
A Seção \ref{sec:results} discute os resultados obtidos e, finalmente, 
a Seção \ref{sec:conclusion} conclui o artigo.

\section{Modelo do Sistema}
\label{sec:model}

\subsection{Modelo de Motores PMSC}
O modelo dinâmico dos PMSMs pode ser derivado a partir das equações de tensão de fase. 
Conforme descrito em \cite{b2}, as tensões nos enrolamentos do estator são definidas por:

\begin{equation}
    \begin{bmatrix} v_a \\ v_b \\ v_c \end{bmatrix} = 
    \begin{bmatrix} R_s & 0 & 0 \\ 0 & R_s & 0 \\ 0 & 0 & R_s \end{bmatrix} 
    \begin{bmatrix} i_a \\ i_b \\ i_c \end{bmatrix} + 
    \frac{d}{dt} \begin{bmatrix} \psi_a \\ \psi_b \\ \psi_c \end{bmatrix}
    \label{eq:vabc}
\end{equation}

onde $\psi$ representa o fluxo total concatenado em cada enrolamento, dado por:

\begin{equation}
    \begin{bmatrix} \psi_a \\ \psi_b \\ \psi_c \end{bmatrix} = 
    \begin{bmatrix}
    L_{aa} & L_{ab} & L_{ac} \\
    L_{ba} & L_{bb} & L_{bc} \\
    L_{ca} & L_{cb} & L_{cc}
    \end{bmatrix}
    \begin{bmatrix} i_a \\ i_b \\ i_c \end{bmatrix} + 
    \begin{bmatrix} \psi_{am} \\ \psi_{bm} \\ \psi_{cm} \end{bmatrix}
    \label{eq:psi_abc}
\end{equation}

A matriz de indutâncias $\mathbf{L}_{abc}$ contém termos que variam com a posição do 
rotor $\theta_m$ devido à saliência dos polos. Como apresentado por \cite{b3}, as 
indutâncias próprias e mútuas são dadas por:

\begin{align}
    L_{aa} &= L_{al} + L_{aa0} + L_{g2} \cos(2\theta_e) \\
    L_{bb} &= L_{al} + L_{aa0} + L_{g2} \cos(2\theta_e + 2\pi/3) \\
    L_{cc} &= L_{al} + L_{aa0} + L_{g2} \cos(2\theta_e - 2\pi/3) \\
    L_{ab} &= -\frac{1}{2}L_{aa0} + L_{g2} \cos(2\theta_e - 2\pi/3) \\
    L_{bc} &= -\frac{1}{2}L_{aa0} + L_{g2} \cos(2\theta_e) \\
    L_{ca} &= -\frac{1}{2}L_{aa0} + L_{g2} \cos(2\theta_e + 2\pi/3)
\end{align}

onde $L_{al}$ é a indutância de dispersão, $L_{aa0}$ é a componente constante da indutância 
mútua e $L_{g2}$ representa a amplitude da variação de indutância devido à saliência.

Para simplificar a análise, aplica-se a Transformada de Park para converter as variáveis 
do referencial trifásico ($abc$) para o referencial síncrono girante ($dq0$). 
A transformação é definida por $\mathbf{x}_{dq0} = \mathbf{T} \mathbf{x}_{abc}$, 
onde $\mathbf{T}$ é a matriz de transformação dada por:

\begin{equation}
    \mathbf{T} = \frac{2}{3} \begin{bmatrix} 
    \cos(\theta_e) & \cos(\theta_e - \frac{2\pi}{3}) & \cos(\theta_e + \frac{2\pi}{3}) \\
    -\sin(\theta_e) & -\sin(\theta_e - \frac{2\pi}{3}) & -\sin(\theta_e + \frac{2\pi}{3}) \\
    \frac{1}{2} & \frac{1}{2} & \frac{1}{2}
    \end{bmatrix}
\end{equation}

Aplicando a Transformada de Park na equação \eqref{eq:vabc}, obtemos a 
equação de tensão no referencial $dq0$:

\begin{equation}
    \mathbf{v}_{dq0} = \mathbf{T} \mathbf{v}_{abc} = 
    \mathbf{T} \mathbf{R} \mathbf{i}_{abc} + 
    \mathbf{T} \frac{d\boldsymbol{\psi}_{abc}}{dt}
\end{equation}

Sabendo que $\mathbf{i}_{abc} = \mathbf{T}^{-1} \mathbf{i}_{dq0}$ e 
$\boldsymbol{\psi}_{abc} = \mathbf{T}^{-1} \boldsymbol{\psi}_{dq0}$:

\begin{equation}
    \mathbf{v}_{dq0} = 
    \mathbf{R} \mathbf{i}_{dq0} + 
    \mathbf{T} \frac{d}{dt} (\mathbf{T}^{-1} \boldsymbol{\psi}_{dq0})
    \label{eq:vdq_flux}
\end{equation}

Expandindo a derivada do produto::

\begin{equation}
    \frac{d}{dt} (\mathbf{T}^{-1} \boldsymbol{\psi}_{dq0}) = 
    \mathbf{T}^{-1} \frac{d\boldsymbol{\psi}_{dq0}}{dt} + 
    \frac{d\mathbf{T}^{-1}}{dt} \boldsymbol{\psi}_{dq0}
\end{equation}

Substituindo na equação \eqref{eq:vdq_flux}:

\begin{equation}
    \mathbf{v}_{dq0} = 
    \mathbf{R} \mathbf{i}_{dq0} + 
    \frac{d\boldsymbol{\psi}_{dq0}}{dt} + 
    \mathbf{T} \frac{d\mathbf{T}^{-1}}{dt} \boldsymbol{\psi}_{dq0}
    \label{eq:vdq_flux_opened}
\end{equation}

A matriz inversa da transformada de Park é definida como:

\begin{equation}
    \mathbf{T}^{-1} = \begin{bmatrix} 
    \cos(\theta_e) & -\sin(\theta_e) & 1 \\
    \cos(\theta_e - \frac{2\pi}{3}) & -\sin(\theta_e - \frac{2\pi}{3}) & 1 \\
    \cos(\theta_e + \frac{2\pi}{3}) & -\sin(\theta_e + \frac{2\pi}{3}) & 1
    \end{bmatrix}
\end{equation}

Sua derivada em relação ao tempo é:

\begin{equation}
    \frac{d\mathbf{T}^{-1}}{dt} = \omega_e \begin{bmatrix} 
    -\sin(\theta_e) & -\cos(\theta_e) & 0 \\
    -\sin(\theta_e - \frac{2\pi}{3}) & -\cos(\theta_e - \frac{2\pi}{3}) & 0 \\
    -\sin(\theta_e + \frac{2\pi}{3}) & -\cos(\theta_e + \frac{2\pi}{3}) & 0
    \end{bmatrix}
\end{equation}

Portanto, o termo $\mathbf{T} \frac{d\mathbf{T}^{-1}}{dt}$ resulta em um acoplamento cruzado
entre os eixos $d$ e $q$ devido à velocidade angular elétrica $\omega_e$:

\begin{equation}
    \mathbf{T} \frac{d\mathbf{T}^{-1}}{dt} = 
    \omega_e \begin{bmatrix} 0 & -1 & 0 \\ 1 & 0 & 0 \\ 0 & 0 & 0 \end{bmatrix}
    \label{eq:acoplamento}
\end{equation}

Em seguida, aplica-se a transformada de Park na equação de fluxo (2):

\begin{equation}
    \mathbf{T} \boldsymbol{\psi}_{abc} = 
    \mathbf{T} (\mathbf{L}_{abc} \mathbf{i}_{abc} + 
    \boldsymbol{\psi}_{m,abc})
\end{equation}

\begin{equation}
    \boldsymbol{\psi}_{dq0} = 
    \mathbf{T} \mathbf{L}_{abc} \mathbf{T}^{-1} \mathbf{i}_{dq0} + 
    \mathbf{T} \boldsymbol{\psi}_{m,abc}
\end{equation}

A matriz de indutância no referencial $dq0$, $\mathbf{L}_{dq0}$, é obtida pela 
transformação de similaridade $\mathbf{T} \mathbf{L}_{abc} \mathbf{T}^{-1}$. 
Esta operação desacopla as fases e elimina a dependência da posição do rotor, 
resultando em uma matriz diagonal constante:

\begin{equation}
    \mathbf{L}_{dq0} = \begin{bmatrix} L_d & 0 & 0 \\ 0 & L_q & 0 \\ 0 & 0 & L_{al} \end{bmatrix}
\end{equation}

onde as indutâncias de eixo direto e quadratura são constantes, e dadas por:

\begin{equation}
    L_d = L_{al} + \frac{3}{2}(L_{aa0} + L_{g2})
\end{equation}
\begin{equation}
    L_q = L_{al} + \frac{3}{2}(L_{aa0} - L_{g2})
\end{equation}

Definindo o fluxo dos ímãs transformado como 
$\boldsymbol{\psi}_{m,dq0} = \mathbf{T} \boldsymbol{\psi}_{m,abc}$, 
a equação de fluxo no referencial $dq0$ é dada por:

\begin{equation}
    \boldsymbol{\psi}_{dq0} = \mathbf{L}_{dq0} \mathbf{i}_{dq0} + \boldsymbol{\psi}_{m,dq0}
    \label{eq:flux_dq}
\end{equation}

Substituindo \eqref{eq:flux_dq} em \eqref{eq:vdq_flux_opened}:

\begin{equation}
    \mathbf{v}_{dq0} = 
    \mathbf{R} \mathbf{i}_{dq0} + 
    \mathbf{L}_{dq0} \frac{d\mathbf{i}_{dq0}}{dt} + 
    \mathbf{T} \frac{d\mathbf{T}^{-1}}{dt} \mathbf{L}_{dq0} \mathbf{i}_{dq0} + 
    \mathbf{e}_{dq0}
\end{equation}

onde $\mathbf{e}_{dq0}$ é a força contra-eletromotriz no referencial $dq0$, dada por:

\begin{equation}
    \mathbf{e}_{dq0} = 
    \frac{d\boldsymbol{\psi}_{m,dq0}}{dt} + 
    \mathbf{T} \frac{d\mathbf{T}^{-1}}{dt} \boldsymbol{\psi}_{m,dq0}
\end{equation}

A forma matricial explícita no referencial $dq$ torna-se:

\begin{equation}
    \frac{d\mathbf{i}_{dq0}}{dt} = 
    \mathbf{A} \mathbf{i}_{dq0} + 
    \mathbf{B} (\mathbf{v}_{dq0} - 
    \mathbf{e}_{dq0})
\end{equation}

onde as matrizes de estado $\mathbf{A}$ e de entrada $\mathbf{B}$ são dadas por:

\begin{equation}
    \mathbf{A} = \begin{bmatrix} -\frac{R_s}{L_d} & \omega_e \frac{L_q}{L_d} \\ -\omega_e \frac{L_d}{L_q} & -\frac{R_s}{L_q} \end{bmatrix}, \quad
    \mathbf{B} = \begin{bmatrix} \frac{1}{L_d} & 0 \\ 0 & \frac{1}{L_q} \end{bmatrix}
\end{equation}

Isolando as derivadas para cada componente:

\begin{equation}
    \frac{dI_d}{dt} = \frac{1}{L_d} (V_d - R_s I_d + \omega_e L_q I_q - e_d)
\end{equation}

\begin{equation}
    \frac{dI_q}{dt} = \frac{1}{L_q} (V_q - R_s I_q - \omega_e L_d I_d - e_q)
\end{equation}

\subsection{Diferenças entre BLDC e BLAC}
Ambos são motores síncronos de ímãs permanentes, mas a principal distinção entre o motor BLDC e o 
BLAC reside na distribuição do fluxo magnético e na forma de onda da força contra-eletromotriz (Back-EMF).

\subsubsection{BLAC}
O Motor Síncrono de Ímãs Permanentes (PMSM), ou BLAC, possui uma distribuição de fluxo senoidal. 
No referencial síncrono $dq$, as componentes da força contra-eletromotriz tornam-se constantes:

\begin{equation}
    e_d = 0
\end{equation}

\begin{equation}
    e_q = \omega_e \lambda_m
\end{equation}

Isso simplifica o controle, pois as referências de corrente podem ser constantes para torque constante.

\subsubsection{BLDC}
O motor BLDC possui uma distribuição de fluxo trapezoidal. Ao contrário do BLAC, as componentes 
$e_d$ e $e_q$ no referencial síncrono não são constantes, mas variam com a posição do rotor, 
apresentando ondulações características.

\begin{figure}[htbp]
\centerline{\includegraphics[width=\columnwidth]{Figs/back_emf_plot.png}}
\caption{Formas de onda da força contra-eletromotriz trapezoidal no referencial 
trifásico ($e_a, e_b, e_c$) e suas componentes no referencial síncrono ($e_d, e_q$).}
\label{fig:back_emf}
\end{figure}

A Fig. \ref{fig:back_emf} ilustra que $e_q$ apresenta ondulações 
(harmônicos de ordem $6k$) em vez de ser um valor DC puro, e $e_d$ também 
oscila em torno de zero. Essas variações introduzem ripple de torque 
se o controle FOC padrão (projetado para PMSM) for aplicado sem compensação.

\subsection{Equação de Torque}
A potência instantânea de entrada nos terminais do estator no referencial $abc$ é dada por:

\begin{equation}
    P_{abc} = v_a i_a + v_b i_b + v_c i_c
\end{equation}

Utilizando a transformação de Park, e considerando a transformação 
invariante em amplitude e a componente zero nula, a potência pode 
ser reescrita no referencial $dq0$:

\begin{equation}
    P_{dq} = \frac{3}{2} (v_d i_d + v_q i_q)
    \label{eq:potencia_dq}
\end{equation}

Substituindo as equações de tensão $v_d$ e $v_q$ na equação de potência 
(\ref{eq:vdq_flux_opened} em \ref{eq:potencia_dq}):

\begin{equation}
\begin{split}
    P_{dq} = \frac{3}{2} \bigg[ i_d \left( R_s i_d + L_d \frac{di_d}{dt} - \omega_e L_q i_q + e_d \right) \\
    + i_q \left( R_s i_q + L_q \frac{di_q}{dt} + \omega_e L_d i_d + e_q \right) \bigg]
\end{split}
\end{equation}

Reagrupando os termos, podemos identificar três componentes distintas de potência:

\begin{equation}
\begin{split}
    P_{dq} = \underbrace{\frac{3}{2} R_s (i_d^2 + i_q^2)}_{P_{cu}} 
    + \underbrace{\frac{3}{2} \left( L_d i_d \frac{di_d}{dt} + L_q i_q \frac{di_q}{dt} \right)}_{P_{mag}} \\
    + \underbrace{\frac{3}{2} \left[ (e_d i_d + e_q i_q) + \omega_e (L_d - L_q) i_d i_q \right]}_{P_{em}}
\end{split}
\end{equation}

onde $P_{cu}$ representa as perdas resistivas no cobre, $P_{mag}$ é a 
taxa de variação da energia magnética armazenada, e $P_{em}$ é a potência 
eletromecânica convertida. Portanto, a potência eletromecânica é:

\begin{equation}
    P_{em} = \frac{3}{2} (e_d i_d + e_q i_q) + \frac{3}{2} \omega_e (L_d - L_q) i_d i_q
\end{equation}

O torque eletromagnético $T_e$ relaciona-se com a potência mecânica pela 
velocidade angular do rotor $\omega_m$. Considerando $\omega_e = P \omega_m$, 
onde $P$ é o número de pares de polos:

\begin{equation}
    T_e = \frac{P_{em}}{\omega_m} = \frac{P P_{em}}{\omega_e}
\end{equation}

Substituindo a expressão de $P_{em}$, podemos separar o torque em 
duas componentes: o torque de alinhamento (ou síncrono), 
devido à interação com a força contra-eletromotriz, e o 
torque de relutância, devido à assimetria do rotor:

\begin{equation}
    T_e = 
    \underbrace{\frac{3}{2} P \frac{e_d i_d + e_q i_q}{\omega_e}}_{T_{sinc}} + 
    \underbrace{\frac{3}{2} P (L_d - L_q) i_d i_q}_{T_{relut}}
\end{equation}

O termo $T_{relut}$ surge em máquinas com saliência ($L_d \neq L_q$), 
sendo proporcional a $(L_d - L_q) I_d I_q$.

Para máquinas de ímãs permanentes com $L_d = L_q$, o torque de relutância se torna zero.

No caso do BLAC, onde $e_d = 0$ e $e_q = \omega_e \lambda_m$, a equação 
simplifica-se para a forma clássica:

\begin{equation}
    T_e = \frac{3}{2} P \lambda_m I_q
\end{equation}

Para o motor BLDC, como visto anteriormente, $e_d$ e $e_q$ variam com 
a posição do rotor, resultando em ondulações de torque se as correntes 
$I_d$ e $I_q$ forem mantidas constantes. A simulação utiliza a forma 
geral baseada nas componentes de força contra-eletromotriz para capturar 
este comportamento.

A dinâmica mecânica é descrita por:

\begin{equation}
    J \frac{d\omega_m}{dt} = T_e - T_L - B \omega_m - T_c
    \label{eq:mech}
\end{equation}

onde $J$ é o momento de inércia, $\omega_m$ é a velocidade mecânica, 
$T_L$ é o torque de carga, $B$ é o coeficiente de atrito viscoso, 
e $T_c$ é o torque de atrito de Coulomb.

\subsection{Parâmetros do Motor}
Os parâmetros do motor utilizado neste trabalho, baseados em \cite{b3}, são apresentados na Tabela \ref{tab:motor_params}.

\begin{table}[htbp]
\caption{Parâmetros do Motor BLAC}
\begin{center}
\begin{tabular}{ccc}
\toprule
\textbf{Parâmetro} & \textbf{Símbolo} & \textbf{Valor} \\
\midrule
Pares de polos & $P$ & 21 \\
Resistência do estator & $R_s$ & 4.485 $\Omega$ \\
Indutância de eixo direto & $L_d$ & 54.8 mH \\
Indutância de eixo em quadratura & $L_q$ & 54.8 mH \\
Fluxo magnético & $\lambda_m$ & 0.201 Wb \\
Momento de inércia & $J$ & 0.1444 kg$\cdot$m$^2$ \\
Atrito viscoso & $B$ & 0.0057 Nms/rad \\
\bottomrule
\end{tabular}
\label{tab:motor_params}
\end{center}
\end{table}

\section{Estratégia de Controle}
\label{sec:control}

A estratégia de controle adotada é o Controle Orientado a Campo (FOC) projetado 
para um motor BLAC. O diagrama de blocos geral do sistema de 
controle é apresentado na Fig. \ref{fig:foc_diagram}. O sistema consiste em uma malha 
externa de velocidade e duas malhas internas de corrente ($I_d$ e $I_q$).

A referência de velocidade é comparada com a velocidade medida, gerando uma referência 
de corrente de quadratura $I_q^*$ através de um controlador PI. A referência de 
corrente de eixo direto $I_d^*$ é mantida em zero para maximizar o torque por 
ampère (estratégia MTPA para SPMSM). As correntes medidas são transformadas para 
o referencial síncrono e controladas por controladores PI independentes, gerando 
as tensões de referência para o algoritmo SVPWM.

\begin{figure}[htbp]
\centerline{\includegraphics[width=\columnwidth]{Figs/FOC_diagram.png}}
\caption{Diagrama de blocos geral do controle FOC.}
\label{fig:foc_diagram}
\end{figure}

\subsection{Modelo do Inversor}
O Inversor de Fonte de Tensão (VSI) trifásico é modelado idealmente, 
assumindo que as tensões de referência geradas pelo controlador são 
aplicadas com precisão aos terminais do motor, limitadas apenas pela 
tensão do barramento CC $V_{bus}$. Os limites da Modulação por Largura 
de Pulso Vetorial Espacial (SVPWM) são considerados saturando a magnitude 
do vetor de tensão para $V_{bus}/\sqrt{3}$ para um movimento suave.

\subsection{Projeto do Controlador de Corrente}
O controle de corrente é realizado no referencial síncrono $dq$, utilizando dois 
controladores PI independentes para regular as correntes $I_d$ e $I_q$.
O diagrama de blocos do controlador de corrente é mostrado 
na Fig. \ref{fig:current_controler}.

\begin{figure}[htbp]
\centerline{\includegraphics[width=\columnwidth]{Figs/current_controler.png}}
\caption{Diagrama de blocos do controlador de corrente \cite{b3}.}
\label{fig:current_controler}
\end{figure}

A banda passante ($\omega_b$) da malha de corrente é projetada para ser aproximadamente 
10 vezes maior que a da malha de velocidade, garantindo o desacoplamento dinâmico. 
Neste trabalho, adotou-se $\omega_b = 350$ Hz e $\xi = 4$, seguindo o 
controlador desenvolvido por \cite{b3}. Os ganhos resultantes 
são calculados, tendo como premissas que o acoplamento entre os 
eixos $d$ e $q$ é tratado como um distúrbio a ser compensado, 
que a dinâmica dos eixos $d$ e $q$ são iguais (válido para $L_d$ = $L_q$), 
e que a resistencia do motor seja muito menor que o ganho do controlador:

\begin{equation}
    k_{p} = \frac{\xi \omega_b 2 L_q}{\sqrt{2\xi^2 + 1 + \sqrt{(1+2\xi)^2+1}}}
\end{equation}

\begin{equation}
    k_{i} = \frac{L_q \omega_b^2}{2\xi^2 + 1 + \sqrt{(1+2\xi)^2+1}}
\end{equation}

Substituindo os parâmetros, obtém-se $k_{p} = 119$ e $k_{i} = 4015$.

\subsection{Projeto do Controlador de Velocidade}
O controlador de velocidade é responsável por regular a velocidade mecânica 
do rotor, gerando a referência de corrente $I_q^*$ para a malha interna. 
Utiliza-se um controlador PI. O diagrama de blocos do controlador de velocidade é 
apresentado na Fig. \ref{fig:speed_controler}. 
A referência de corrente de eixo direto $I_d^*$ é mantida em zero.


\begin{figure}[htbp]
\centerline{\includegraphics[width=\columnwidth]{Figs/speed_controler.png}}
\caption{Diagrama de blocos do controlador de velocidade \cite{b3}.}
\label{fig:speed_controler}
\end{figure}

O projeto do controlador assume que a dinâmica da malha de corrente é 
suficientemente rápida para ser considerada ideal (ganho unitário) na 
faixa de frequências de interesse da malha de velocidade. A banda 
passante escolhida foi $\omega_b = 35$ Hz com um fator de amortecimento 
$\xi = 1.0$, novamente seguindo o controlador desenvolvido por \cite{b3}. 
As equações para os ganhos, considerando o torque de carga 
e atrito de Coulomb como distúrbios e o atrito viscoso desprezível frente 
à inércia, são dadas por:

\begin{equation}
    k_{p} = \frac{\xi \omega_b 2 J}{K_t \sqrt{2\xi^2 + 1 + \sqrt{(1+2\xi)^2+1}}}
\end{equation}

\begin{equation}
    k_{i} = \frac{J \omega_b^2}{K_t (2\xi^2 + 1 + \sqrt{(1+2\xi)^2+1})}
\end{equation}

Os ganhos obtidos para o controlador de velocidade são $k_{p} = 1.25$ e $k_{i} = 55$.

\section{Simulador}
\label{sec:simulator}

Para validar a análise comparativa, foi desenvolvido um simulador modular em 
Python, projetado para flexibilidade e facilidade de manutenção, pode ser 
visto no apêndice \ref{app:simulator}. A estrutura 
do simulador é baseada em componentes independentes que interagem através de 
interfaces bem definidas, permitindo a substituição de modelos de motor e 
estratégias de controle sem a necessidade de reescrever o código principal.

A arquitetura do simulador é composta pelos seguintes módulos principais:
\begin{itemize}
    \item \textbf{Motor}: Define a física da máquina elétrica. Foram implementadas 
    classes distintas para o motor BLDC e para o BLAC, ambas herdando 
    uma interface comum que expõe métodos para o cálculo da dinâmica 
    eletromecânica. Isso permite a troca direta entre os modelos de motor no script 
    principal.
    \item \textbf{Controller}: Implementa a lógica de controle, como o FOC. Este 
    módulo recebe as referências e as medições dos sensores para calcular as tensões 
    de referência.
    \item \textbf{Inverter}: Modela o comportamento do inversor de potência, 
    convertendo as tensões de referência em tensões aplicadas aos terminais do 
    motor, considerando a tensão do barramento DC.
    \item \textbf{Sensors}: Simula a aquisição de dados, fornecendo medições de 
    corrente, posição e velocidade, podendo incluir ruídos ou atrasos para maior 
    realismo.
\end{itemize}

O ciclo de simulação, executado em \texttt{Simulate.py}, opera em passos de tempo 
discretos ($T_s$). Em cada iteração, o fluxo de dados segue a sequência:
\begin{enumerate}
    \item \textbf{Definição de Perfil}: Atualização das referências de velocidade 
    e torque de carga conforme o tempo de simulação.
    \item \textbf{Sensoriamento}: O módulo de sensores lê o estado atual do motor.
    \item \textbf{Controle}: O controlador calcula as ações de controle baseadas 
    nas leituras dos sensores e nas referências.
    \item \textbf{Atuação}: O inversor aplica as tensões resultantes ao motor.
    \item \textbf{Física}: O modelo do motor atualiza suas variáveis de estado 
    (correntes, velocidade, posição) resolvendo as equações diferenciais do sistema.
    \item \textbf{Registro}: As variáveis de interesse são armazenadas para 
    análise posterior.
\end{enumerate}

Essa abordagem modular facilitou a comparação direta entre o desempenho do FOC em 
motores BLDC e BLAC, garantindo que as mesmas condições de controle e simulação 
fossem aplicadas a ambos os casos, isolando as diferenças intrínsecas das máquinas.
 Os parâmetros do motor utilizados são apresentados na Tabela \ref{tab:motor_params}.

O perfil de simulação segue o padrão desenvolvido em \cite{b3}, que consiste em:
\begin{itemize}
    \item $t=0.0s$: Início em 40 RPM.
    \item $t=0.2s$: Degrau de torque de carga de 20 Nm aplicado.
    \item $t=0.4s$: Degrau de referência de velocidade para 80 RPM.
    \item $t=0.6s$: Degrau de referência de velocidade de volta para 40 RPM.
    \item $t=0.8s$: Torque de carga removido.
\end{itemize}

\section{Resultados}
\label{sec:results}
A Fig. \ref{fig:results_speed_torque} e a Fig. \ref{fig:results_currents} mostram 
a resposta do sistema comparando o motor BLAC e o motor BLDC sob o mesmo controle FOC.

\begin{figure}[htbp]
\centerline{\includegraphics[width=\columnwidth]{Figs/comparison_speed_torque.png}}
\caption{Comparação de Velocidade e Torque entre BLAC e BLDC.}
\label{fig:results_speed_torque}
\end{figure}

O controlador de velocidade rastreia a referência de RPM com precisão para ambos os 
motores, mesmo tendo uma leve oscilação e ter o comportamento levemente mais rápido 
no caso do BLDC.

\begin{figure}[htbp]
\centerline{\includegraphics[width=\columnwidth]{Figs/comparison_currents.png}}
\caption{Comparação das Correntes $I_d$ e $I_q$ entre BLAC e BLDC.}
\label{fig:results_currents}
\end{figure}

Já para o torque, observa-se que o motor BLDC apresenta um ripple 
significativo em comparação com o BLAC. Este ripple é intrínseco à aplicação do controle 
FOC, projetado para formas de onda senoidais, em uma máquina com força contra-eletromotriz 
trapezoidal. A frequência fundamental deste ripple é de 6 vezes a frequência elétrica, 
correspondendo às comutações que ocorreriam em um controle trapezoidal padrão, efeito 
esse que pode ser observado no intervalo $0.4 < t < 0.6$ s, em que a velocidade é dobrada, e 
a frequência do ripple de torque também é dobrada. 

As correntes $I_d$ e $I_q$ no caso do BLDC (Fig. \ref{fig:results_currents}) mostram oscilações claras. O controlador PI de corrente tenta compensar a variação da Back-EMF trapezoidal, que não é constante no referencial $dq$, resultando nessas ondulações. Embora a velocidade média seja mantida, a qualidade do torque é degradada, o que pode gerar vibrações e ruído acústico em aplicações reais.

\section{Conclusão}
\label{sec:conclusion}
Uma simulação completa de um acionamento PMSM usando FOC foi apresentada 
e comparada com a aplicação da mesma estratégia em um motor BLDC. A 
implementação modular em Python permitiu uma análise detalhada das 
diferenças de desempenho.

Os resultados confirmam que, embora o FOC possa controlar a velocidade 
de um motor BLDC com eficácia, ele introduz um ripple de torque 
considerável devido ao descasamento entre a estratégia de controle 
(baseada em modelos senoidais) e a física do motor (Back-EMF trapezoidal). 
Para aplicações de alto desempenho utilizando motores BLDC, estratégias 
de minimização de ripple de torque ou o uso de controle trapezoidal 
dedicado seriam mais apropriados. O ambiente de simulação desenvolvido 
serve como uma ferramenta valiosa para estudar e validar tais estratégias 
de controle avançado.


\begin{thebibliography}{00}
\bibitem{pillay1989} P. Pillay and R. Krishnan, "Modeling, simulation, and analysis of permanent-magnet motor drives. I. The permanent-magnet synchronous motor drive," IEEE Transactions on Industry Applications, vol. 25, no. 2, pp. 265-273, March-April 1989.
\bibitem{b2} MathWorks, "BLDC - Three-winding brushless direct current motor with trapezoidal flux distribution," [Online]. Available: https://www.mathworks.com/help/sps/ref/bldc.html.
\bibitem{b4} MathWorks, "PMSM - Permanent Magnet Synchronous Motor," [Online]. Available: https://www.mathworks.com/help/sps/ref/pmsm.html.
\bibitem{b3} Matheus Alexandre Bevilaqua, "Implementação do Controle de Velocidade de Motores Síncronos a Ímãs Permanentes em Plataforma LabVIEW FPGA", Universidade do Estado de Santa Catarina, 2015.
% \bibitem{krause} P. C. Krause, O. Wasynczuk, and S. D. Sudhoff, \textit{Analysis of Electric Machinery and Drive Systems}, 2nd ed. Piscataway, NJ: IEEE Press, 2002.
\end{thebibliography}

\appendices

\section{Código da Simulação}
\label{app:simulator}
Os códigos fonte da simulação desenvolvida em Python são apresentados a seguir. 
O projeto completo também pode ser acessado no repositório GitHub: 
\url{https://github.com/FelipeLenschow/Artigo-FOC-no-BLAC-vs-BLDC}.

\subsection{Simulate.py}
\lstinputlisting{../Sim/Simulate.py}

\subsection{BLACMotor.py}
\lstinputlisting{../Sim/BLACMotor.py}

\subsection{BLDCMotor.py}
\lstinputlisting{../Sim/BLDCMotor.py}

\subsection{FOCController.py}
\lstinputlisting{../Sim/FOCController.py}

\subsection{Inverter.py}
\lstinputlisting{../Sim/Inverter.py}

\subsection{Sensors.py}
\lstinputlisting{../Sim/Sensors.py}

\subsection{Transforms.py}
\lstinputlisting{../Sim/Transforms.py}

\end{document}
